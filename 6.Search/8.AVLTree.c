#include <stdio.h>
#include <stdlib.h>

//?????????
#define LH +1 //??
#define EH 0  //??
#define RH -1 //??

typedef int ElemType;

//???????
struct BSTNode
{
    ElemType data;
    int bf; //balance flag
    struct BSTNode *lchild, *rchild;
};

typedef struct BSTNode *BSTree;

//?? T ??????????????? T ??????????
void R_Rotate(BSTree *T)
{
    BSTree LeftChild = (*T)->lchild;  //LeftChild??T???????
    (*T)->lchild = LeftChild->rchild; //LeftChild???????T????
    LeftChild->rchild = *T;
    *T = LeftChild; //??????LeftChild
}

//?? T ??????????????? T ??????????
void L_Rotate(BSTree *T)
{
    BSTree RightChild = (*T)->rchild;  //RightChild??T???????
    (*T)->rchild = RightChild->lchild; //RightChild???????T????
    RightChild->lchild = *T;
    *T = RightChild; //??????RightChild
}

//???? T ?????????????????????????? T ???????
void LeftBalance(BSTree *T)
{
    BSTree LeftChild = (*T)->lchild; //LeftChild??T???????
    BSTree RightChild;
    //??T???????????????
    switch (LeftChild->bf)
    {
    case LH: //??????T????????????????????
        (*T)->bf = LeftChild->bf = EH;
        R_Rotate(T);
        break;
    case RH:                            //??????T????????????????
        RightChild = LeftChild->rchild; //RightChild??T?????????
        switch (RightChild->bf)         //??T??????bf
        {
        case LH:
            (*T)->bf = RH;
            LeftChild->bf = EH;
            break;
        case EH:
            (*T)->bf = LeftChild->bf = EH;
            break;
        case RH:
            (*T)->bf = EH;
            LeftChild->bf = LH;
            break;
        }
        RightChild->bf = EH;
        L_Rotate(&(*T)->lchild); //?T?????????
        R_Rotate(T);             //?T?????
        break;
    }
}

//???? T ?????????????????????????? T ???????   ??
void RightBalance(BSTree *T)
{
    BSTree RightChild = (*T)->rchild;
    BSTree LeftChild;
    switch (RightChild->bf)
    {
    case RH:
        (*T)->bf = RightChild->bf = EH;
        L_Rotate(T);
        break;
    case LH:
        LeftChild = RightChild->lchild;
        switch (LeftChild->bf)
        {
        case LH:
            (*T)->bf = EH;
            RightChild->bf = RH;
            break;
        case EH:
            (*T)->bf = RightChild->bf = EH;
            break;
        case RH:
            (*T)->bf = EH;
            RightChild->bf = LH;
            break;
        }
        LeftChild->bf = EH;
        R_Rotate(&(*T)->rchild);
        L_Rotate(T);
        break;
    }
}

int InsertAVL(BSTree *T, ElemType e, int *taller)
{
    //????????????? e ????
    if ((*T) == NULL)
    {
        (*T) = (BSTree)malloc(sizeof(struct BSTNode));
        (*T)->bf = EH;
        (*T)->data = e;
        (*T)->lchild = NULL;
        (*T)->rchild = NULL;
        *taller = 1;
    }
    //???????????? e ????????
    else if (e == (*T)->data)
    {
        *taller = 0;
        return 0;
    }
    //?? e ???? T ????????? T ?????
    else if (e < (*T)->data)
    {
        //???????????????????????
        if (!InsertAVL(&(*T)->lchild, e, taller))
            return 0;
        //????????????????? +1
        if (*taller)
        {
            //????? T ???????????????????????????????????? T ?????????? 1 ??????????????????????????????
            switch ((*T)->bf)
            {
            case LH:
                LeftBalance(T);
                *taller = 0;
                break;
            case EH:
                (*T)->bf = LH;
                *taller = 1;
                break;
            case RH:
                (*T)->bf = EH;
                *taller = 0;
                break;
            }
        }
    }
    //???? e>T->data ???????? T ?????????????????????????
    else
    {
        if (!InsertAVL(&(*T)->rchild, e, taller))
            return 0;
        if (*taller)
        {
            switch ((*T)->bf)
            {
            case LH:
                (*T)->bf = EH;
                *taller = 0;
                break;
            case EH:
                (*T)->bf = RH;
                *taller = 1;
                break;
            case RH:
                RightBalance(T);
                *taller = 0;
                break;
            }
        }
    }
    return 1;
}

//???????????????????? e ???
int FindNode(BSTree root, ElemType e, BSTree *pos)
{
    BSTree pt = root;
    (*pos) = NULL;
    while (pt)
    {
        if (pt->data == e)
        {
            //?????pos????????true
            (*pos) = pt;
            return 1;
        }
        else if (pt->data > e)
        {
            pt = pt->lchild;
        }
        else
            pt = pt->rchild;
    }
    return 0;
}

//?????????
void PrintOrder(BSTree T)
{
    if (T != NULL)
    {
        PrintOrder(T->lchild);
        printf("%d ", T->data);
        PrintOrder(T->rchild);
    }
}

int main()
{
    int i, nArr[] = {1, 23, 45, 34, 98, 9, 4, 35, 23};

    BSTree root = NULL, pos;
    int taller;
    //? nArr?????????????????????
    for (i = 0; i < 9; i++)
    {
        InsertAVL(&root, nArr[i], &taller);
    }
    //??????
    PrintOrder(root);
    //???????????????? 103 ???
    if (FindNode(root, 103, &pos))
    {
        printf("\n%d\n", pos->data);
    }
    else
    {
        printf("\nNot find this Node\n");
    }

    return 0;
}
